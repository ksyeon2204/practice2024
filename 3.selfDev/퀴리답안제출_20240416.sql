-- (1) FROM절에 넣기 
SELECT A.ASST_NO
       ,B.USE_EMP_NO
       ,C.USE_EMP_NO
  FROM (
		SELECT  ASST_NO
		        ,INST_CD AS INST_CD
		        ,MIN(SEQ_NO) AS MIN_SEQ_NO
		        ,MAX(SEQ_NO) AS MAX_SEQ_NO
		  FROM TCOM024_ASST_USE_D 
		 GROUP BY ASST_NO, INST_CD
		HAVING COUNT(ASST_NO) > 1
		) A
  LEFT OUTER JOIN TCOM024_ASST_USE_D B
    ON A.ASST_NO = B.ASST_NO
   AND A.INST_CD = B.INST_CD
   AND A.MIN_SEQ_NO = B.SEQ_NO
  LEFT OUTER JOIN TCOM024_ASST_USE_D C
    ON A.ASST_NO = C.ASST_NO
   AND A.INST_CD = C.INST_CD
   AND A.MAX_SEQ_NO = C.SEQ_NO
;

-- (2)-1. WHERE절에 넣기 
SELECT  A.ASST_NO
       ,B.USE_EMP_NO
       ,C.USE_EMP_NO
  FROM (
			SELECT SUB_1.ASST_NO
			      ,SUB_1.INST_CD
				   ,MAX(SUB_1.SEQ_NO) AS MAX_SEQ_NO
				   ,MIN(SUB_1.SEQ_NO) AS MIN_SEQ_NO
			  FROM (
				  SELECT SUB.*
				    FROM (
							SELECT  *
									  ,COUNT(ASST_NO) OVER(PARTITION BY ASST_NO,INST_CD) AS CNT
							  FROM TCOM024_ASST_USE_D
							) SUB
					WHERE SUB.CNT > 1	
			        ) SUB_1
			 GROUP BY SUB_1.ASST_NO, SUB_1.INST_CD
		) A
  LEFT OUTER JOIN TCOM024_ASST_USE_D B
    ON A.ASST_NO = B.ASST_NO
   AND A.INST_CD = B.INST_CD
   AND A.MIN_SEQ_NO = B.SEQ_NO
  LEFT OUTER JOIN TCOM024_ASST_USE_D C
    ON A.ASST_NO = C.ASST_NO
   AND A.INST_CD = C.INST_CD
   AND A.MAX_SEQ_NO = C.SEQ_NO
	;
	
-- (2)-2 WHERE절에 넣기 
SELECT  A.ASST_NO
       ,B.USE_EMP_NO
       ,C.USE_EMP_NO
  FROM (
			SELECT ASST_NO
			     , INST_CD
			     , MIN(SEQ_NO) AS MIN_SEQ_NO
			     , MAX(SEQ_NO) AS MAX_SEQ_NO
			FROM TCOM024_ASST_USE_D 
			WHERE (ASST_NO, INST_CD) IN (
			    SELECT ASST_NO, INST_CD
			    FROM TCOM024_ASST_USE_D 
			    GROUP BY ASST_NO, INST_CD
			    HAVING COUNT(ASST_NO) > 1
			)
			GROUP BY ASST_NO, INST_CD
		) A
  LEFT OUTER JOIN TCOM024_ASST_USE_D B
    ON A.ASST_NO = B.ASST_NO
   AND A.INST_CD = B.INST_CD
   AND A.MIN_SEQ_NO = B.SEQ_NO
  LEFT OUTER JOIN TCOM024_ASST_USE_D C
    ON A.ASST_NO = C.ASST_NO
   AND A.INST_CD = C.INST_CD
   AND A.MAX_SEQ_NO = C.SEQ_NO
;

-- (2)-3. WHERE절에 넣기 
SELECT  A.ASST_NO
       ,B.USE_EMP_NO
       ,C.USE_EMP_NO
  FROM (
			SELECT ASST_NO
			     , INST_CD
			     , MIN(SEQ_NO) AS MIN_SEQ_NO
			     , MAX(SEQ_NO) AS MAX_SEQ_NO
			     ,COUNT(ASST_NO) AS CNT
			FROM TCOM024_ASST_USE_D 
			GROUP BY ASST_NO, INST_CD
		) A
  LEFT OUTER JOIN TCOM024_ASST_USE_D B
    ON A.ASST_NO = B.ASST_NO
   AND A.INST_CD = B.INST_CD
   AND A.MIN_SEQ_NO = B.SEQ_NO
  LEFT OUTER JOIN TCOM024_ASST_USE_D C
    ON A.ASST_NO = C.ASST_NO
   AND A.INST_CD = C.INST_CD
   AND A.MAX_SEQ_NO = C.SEQ_NO
WHERE A.CNT > 1
;

-- 1. 자산사용명세(TCOM024_ASST_USE_D) 테이블의 유니크한 키 컬럼 
-- 유니크 키 컬럼 : ID, INST_CD, ASST_NO, SEQ_NO

-- 2. 유니크한 키의 검증쿼리  
 SELECT ASST_NO
	FROM TCOM024_ASST_USE_D 
  GROUP BY ASST_NO, INST_CD, SEQ_NO
 HAVING COUNT(ASST_NO) > 1;
 
 SHOW INDEX 
 FROM TCOM024_ASST_USE_D 
WHERE Non_unique = 0;
-- Non_unique로 인덱스가 고유(unique)한지 여부를 확인

-- 3. 자산사용명세 테이블에 자산식별자로 일련번호를 채번해야하는 이상한부분을 찾고 쿼리로 다시 채번하는 조회쿼리   
-- 1) 자산번호 'T002201161006030'의  SEQ_NO가  유니크키인데 중복으로 존재.  
 SELECT *
	FROM TCOM024_ASST_USE_D;
 SELECT
	     ASST_NO
		 ,INST_CD
		 ,USE_ST_DT
		 ,USE_ED_DT
		 ,ROW_NUMBER() OVER(PARTITION BY ASST_NO, INST_CD ORDER BY ASST_NO, INST_CD, SEQ_NO) AS SEQ_NO_NUM
	FROM TCOM024_ASST_USE_D;

	
